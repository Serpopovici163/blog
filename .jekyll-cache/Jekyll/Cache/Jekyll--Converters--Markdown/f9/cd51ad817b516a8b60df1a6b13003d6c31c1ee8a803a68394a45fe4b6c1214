I"•<h2 id="lightlink-overview">LightLink Overview</h2>

<p>Control of a vehicleâ€™s external lighting is safety critical, so Iâ€™ve settled on designing a fully-redundant custom circuit board with 12 MOSFET-driven channels to handle â€˜dumbâ€™ lights and 8 addressable channels to handle a set of addressable LED arrays retrofitted throughout the vehicle.</p>

<p>In addition to designing a fully-redundant board, I felt it necessary to minimize the number of functional components in an effort to limit design complexity and reduce the risk of component failure. All lights within the vehicle share a common ground which means they need to be toggled using a high side switch, ergo P-channel MOSFETs. The problem with this is that P-channel MOSFETs are off when the gate voltage high relative to <em>their</em> source which is the car battery whereas the Arduinos I will use to operate the MOSFETs run on 5V. A typical solution for this would be to include some form of transistor to toggle the P-channel MOSFET which would effectively double the components required for a fully redundant solution.</p>

<p><img src="/assets/img/brz/weird_arduino_p_channel_mosfet.png" alt="Picture of plan" style="float: right; width:50%; height:80%; margin-left: 10px;" /></p>

<p>This was not acceptable for me so I did some research and found the picture depicted here to the right. This schematic works by connecting the Arduinoâ€™s 5V to the MOSFET supplyâ€™s 12V but keeping the grounds disconnected. In this way, the Arduino can toggle the MOSFET when it sets digital pin 6 to LOW which appears as -5V to the MOSFET and should be enough to fully excite it. This circuit may work, however MOSFETs have an effective capacitance between their gate and source which needs to be charged in order to switch the MOSFETâ€™s state. Alongside the additional concerns from having two different grounds on a PCB, not having a common ground could lead to unpredictable behaviour when switching the MOSFETs. For this reason, Iâ€™ve elected to use a decoupling capacitor between the +5V and +12V rails while maintaining a board-wide common ground.</p>

<p>An additional requirement in order to have proper redundancy is the ability to identify the status of each individual MOSFET such that a single component failure can be accurately diagnosed by the Arduino. Luckily, thanks to the common ground, I can simply use voltage dividers and followers alongside a summing amplifier to sense the voltage of each MOSFET. Two voltage dividers are included in each set of redundant MOSFETs; one drops the output voltage to 1V whereas the other drops the voltage to 3V. The two voltage dividers then go into a summing amplifier which allows the state of both MOSFETs to be sensed with a single pin. The voltage followers were included to prevent linking the MOSFET outputs as this would affect the accuracy of failure detection whereas the summing amplifier was included since the Arduino only has 16 analog sense pins and there are 24 MOSFETs on the board.</p>

<p>Finally, since I need three op amps for the sensing circuit and will be using quad op amp ICs, I have elected to use the last op amp for a shunt to measure the output current of each MOSFET pair. In this manner, the board can also diagnose blown bulbs or short circuits.</p>

<h3 id="redundant-mosfet-schematic">Redundant MOSFET Schematic</h3>

<p><img src="/assets/img/brz/mosfet_schematic.PNG" alt="MOSFET schematic" /></p>

<p>Two MOSFETs (bottom right) are included in parallel, both of which are immediately followed by a Schottky diode to prevent backflow from the other MOSFET. This is necessary because a diagnostic pin is included prior to the Schottky and senses voltage which would be biased by backflow from the other MOSFET therefore hindering the detection of a MOSFET failure. The diagnostic connections use two sets of voltage dividers and voltage followers (top left) to reduce Q1â€™s voltage to 1V and Q2â€™s voltage to 3V. The outputs of the voltage followers are funneled into a summing amplifier such that the final signal ranges between 0 and 4V. Finally, a differential amplifier (top right) is included for measuring current across the shunt.</p>

<p>MOSFETS SCHEMATIC</p>

<p>For control, two Arduino Mega EMBEDs are inclded. These were chosen because I have about a dozen on hand right now and they have been reliable in my experience. Regardless, two Arduinos with separate CAN transceivers are included on the board as depicted in the schematic below:</p>

<p>OVERALL SCHEMATIC</p>

<p>At any given moment, one of the Arduinos is considered the â€˜masterâ€™. The master is in charge of outputting signals to the MOSFET and addressable channels while simoultaneously communicating its state over to the slave Arduino over a UART connection. The master updates the slave at regular intervals such that the updates themselves function as â€˜heartbeatâ€™ signals assuring the slave that the master is operating optimally. Should the master miss a heartbeat for whatever reason, the slave sends a hardware reset pin to the current master after which it assumes the master role and resumes signal outputs based on the last state update it received over UART. This system also allows the Arduinos to swap roles ever 30 days since my asynchronous code uses the millis() function to keep track of time and its value will exceed the maximum possible variable size in approximately 50 days.</p>

<h3 id="lighting-modifications">Lighting Modifications</h3>

<p>Some modifications require extensive control of the vehicleâ€™s lights however I am not willing to alter anything about the carâ€™s computers so my solution consists of placing relays along the wiring harnesses controlling the vehicleâ€™s lights with two separate computers on each end of the car. Each computer has a combination of mechanical and solid state relays depending on how frequently a light is expected to toggle on/off. Mechanical relays are used for lights that rarely toggle and because they provide a normally closed and normally open set of contacts. This is important because the lighting computers receive constant power regardless of the vehicleâ€™s state and therefore power draw must be minimized when the vehicle is not running.</p>

<p><img src="/assets/img/brz/rear_light_manager.jpg" alt="Rear light manager computer" style="float: right; width:50%; height:80%; margin-left: 10px;" /> The rear lighting computer is pictured to the right and I expect the front computer to be highly similar. It uses four solid state relays (top left) to drive the brake lights and turn signals of the car by connecting them to the carâ€™s battery. The third and fourth brake light of the car (third is in the windshield and fourth is F1 style in bumper) are converted to addressable LEDs and do not require relays. Addressable LEDs have also been integrated into the reverse lights (two lights adjoined to the fourth brake light) and the two rear quarter panel windows of the car. Excluding the solid state relays, the computer contains two mechanical relays (bottom left) for running lights, a CANBUS module (bottom right), an Arduino (top right), and a 5V regulator on the backside. Currently, this computer turns lights on based on whether or not live data is being sent across the CANBUS since it is always powered and I have not yet figured out what value represents the stte of the vehicleâ€™s running lights. This is not ideal since a side effect of my current solution is that running lights turn on when doors open or the car is unlocked etc.</p>
:ET