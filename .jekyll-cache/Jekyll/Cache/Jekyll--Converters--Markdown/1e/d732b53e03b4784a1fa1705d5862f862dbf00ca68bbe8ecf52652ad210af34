I"<p>This page contains any custom PCBs I’ve ordered for the car. The two PCBs currently included are the LightLink module and a custom wake-on-CAN switch, used to cut off power delivery to computers within the car when they are not needed.</p>

<h2 id="lightlink-module-overview">LightLink Module Overview</h2>

<p>Control of a vehicle’s external lighting is safety critical, so I’ve settled on designing a fully-redundant custom circuit board with 12 MOSFET-driven channels to handle ‘dumb’ lights and 8 addressable channels to handle a set of addressable LED arrays retrofitted throughout the vehicle.</p>

<p>The primary challenge with designing a redundant board for this application is the required use of P-channel MOSFETs and the limited analog I/O available on the Arduino Mega I am using for control. P-channel MOSFETs are required since the car’s chassis is a system-wide ground that all components always have access to and we must therefore toggle the high side of a circuit to turn it on and off. This is an issue because P-channel MOSFETs need their gates to be driven low in order to turn on but the MOSFET would operate off of the car battery whereas the driving circuit would be operating at a much lower logic-level voltage. Therefore, an intermediary N-channel MOSFET must be used to drive the P-channel from a logic-level signal.</p>

<p>This board has gone through many design iterations with the first being as described <a href="https://circuitjournal.com/how-to-use-a-p-channel-mosfet-with-an-arduino">here</a>. I initially wanted to solely use P-channel MOSFETs to decrease the number of components but this seemed like a bad idea so, in the end, I decided to settle for a more traditional design. The final design includes the intermediary N-channel MOSFETs to drive the P-channels and is described more in depth below.</p>

<h3 id="redundant-mosfet-schematic">Redundant MOSFET Schematic</h3>

<p><img src="/assets/img/brz/mosfet_schematic.PNG" alt="MOSFET schematic" /></p>

<p>Two MOSFETs (top left) are included in parallel, both of which are immediately followed by a Schottky diode to prevent backflow from the other MOSFET. This is necessary because a diagnostic pin is included prior to the Schottky to sense the voltage at the output of each MOSFET which would be biased by backflow from the other MOSFET therefore hindering the detection of a MOSFET failure. The diagnostic connections use LM324D-based comparators to compare the voltage before the Schottky to the voltage following the Schottky. If the voltage prior to the diode falls below the voltage following the diode, the output of the LM324D swings low. This is by design since I am using digital pins for sensing MOSFET failures and digital pins can be set up as inputs with pull-up resistors in the Arduino meaning that the pin should go low when a failure occurs.</p>

<p>In addition to detecting individual MOSFET failures, the circuit includes a shunt at the MOSFET output. This allows the board to detect a short circuit or burnt light bulb based on the current being drawn from the circuit. I am using 4-op-amp ICs for this circuit and have therefore included a voltage follower on the near-side of the shunt since I had the extra op amp. I’m not sure if this makes sense but I wanted to ensure the op amp does not influence the near side of the shunt which may throw off the current sensing.</p>

<p>OVERALL SCHEMATIC</p>

<p>For control, two Arduino Mega EMBEDs are included. These were chosen because I have about a dozen on hand right now and they have been reliable in my experience. At any given moment, one of the Arduinos is considered the ‘master’. The master is in charge of outputting signals to the MOSFET and addressable channels while simoultaneously communicating its state over to the slave Arduino over a UART connection. The master updates the slave at regular intervals such that the updates themselves function as ‘heartbeat’ signals ensuring the slave that the master is operating normally. Should the master miss a heartbeat for whatever reason, the slave sends a hardware reset signal to the master after which it assumes the master role and resumes signal outputs based on the last state update it received.</p>

<p>Each arduino has separate a separate CAN controller and transceiver. I am using the MCP2515 controller alongside the TCAN1043DQ1 transceiver. The MCP2515 is a well known controller and therefore has many libraries available and the TCAN1043DQ1 transceiver was chosen because it has the ability to ‘wake on CAN’. The TCAN1043DQ1 has a separate power pin that does not require an external regulator and allows it to monitor for activity on the CAN bus. Once activity is detected, it sets the INH pin high which turns on the LightLink. This provides an incredibly low-power solution to ensure this device cannot drain the vehicle’s battery.</p>

<h2 id="wake-on-can-switch">Wake-On-CAN Switch</h2>

<p>The purpose of this board was derived from the development of the <a href="/brz-head-unit">head unit</a>. I needed a way to prevent components from rebooting due to the accessory power cutting off for a split second when the engine starts. My initial solution of using a microcontroller was pretty poor since running a microcontroller 24/7 beats the purpose of a power cutoff board. My second idea of using a RC network, as described in the ‘Behavioural Nightmares’ section of the <a href="/brz-head-unit">head unit</a> page worked, but I wanted more control.</p>

<p>My final solution is to mate a CAN shield with a MOSFET-based power switch. In this manner, I can use</p>
:ET