I"º<h2 id="a-scalable-dynamic-solution-for-monitoring-activity-in-unknown-environments">A scalable dynamic solution for monitoring activity in unknown environments</h2>

<p>At some point in 2021, a friend and I had just finished exploring a construction site and as we were preparing to leave on the first floor, a security guard haphazardly walked in. kLuckily we were out of sight and managed to get away undetected but this presented a need for a system capable of monitoring activity within an uncontrolled environment. So far I have only build PIR sensors for this purpose though I intend to build tripwires and possibly audio sensors.</p>

<h1 id="basic-idea">Basic Idea</h1>

<p>Each sensor runs off of an 18650 Li-Ion cell with a battery protection circuit that enables USB charging and maintains the cell voltage within its acceptable range. Each sensor has an Arduino Nano with a LoRa SX1278 transceiver in addition to its sensing equipment. LoRa modules are ideal since they act as a mesh network and these sensors are intended for use within concrete buildings thus signals will have difficulty travelling far. An additional LoRa module with a high gain antenna connects the LoRa mesh network to the attacker‚Äôs phone or some other notification method. Due to the RF challenges faced by these sensors, they should transmit repeteadly once triggered until the attacker‚Äôs device is able to acknowledge the signal. Based on experimentation, the LoRa modules I own do not natively do this.</p>

<h1 id="update-feb-2022">UPDATE Feb 2022</h1>

<p><img src="/assets/img/lora-sensor-suite/PIR-V2-front.PNG" alt="Front" style="float: right; width:50%; height:50%" />
I‚Äôve decided to migrate from an Arduino to an ESP32 module; this CAD design has space for an ESP32-WROVER module. The reasoning behind this change is that an ESP32 module can be used to pick up bluetooth devices nearby which would allow the attacker to configure the device with their cell phone 
<img src="/assets/img/lora-sensor-suite/PIR-V2-back.PNG" alt="Back" style="float: right; width:50%; height:50%" /> 
and can be used to pick up unknown devices and send alerts even if the sensor itself fails to trip.</p>

<p>The current design does not have space for a battery management circuit so I will need to reiterate but it does successfully house the LoRa SX1278, 18650, and PIR sensor. The general shape of the sensor allows for it to be placed on the floor with the PIR facing 45 degrees upwards or it can be flipped and placed on top of a cabinet, for example, with the PIR facing 45 degrees downwards. The next iteration will likely also include magnets such that the sensor can attach to metallic cabinets, metal hand rails on stairs, light fixtures, etc. I also took apart one of the 433 antennas and noticed that at least 10mm of the rubber housing is left empty so I will take this in account and ommit the rubber housing in future designs.</p>

<h1 id="update-oct-2021">UPDATE Oct 2021</h1>

<h2 id="sensor-construction">Sensor Construction</h2>

<p><img src="/assets/img/lora-sensor-suite/PIR-V1-front.png" alt="Front" style="float: right; width:50%; height:50%" />
Pins 0 and 1 of the Arduino are used for serial communication with the LoRa module (the RX pin of the LoRa module must be disconnected when code is uploaded to Arduino). Pin A0 is for the pair button and other pins are used as required for the relevant sensor. 
<img src="/assets/img/lora-sensor-suite/PIR-V1-back.png" alt="Back" style="float: right; width:50%; height:50%" /> 
Pins M0 and M1 on the module are shorted to ground in order for the module to transmit. The whole assembly is zip tied together in a rather minimalistic form factor but a bit of paint is needed to cover the green and blue circuit boards.</p>

<h2 id="communication-protocol">Communication Protocol</h2>

<p>Each sensor broadcasts an ‚Äòalive‚Äô packet once the pair button has been pressed; this packet contains a unique ID based on the microcontroller‚Äôs serial number to differentiate its ‚Äòalive‚Äô packet from that of other sensors. Alive packets are repeated up until the sensor receives an acknowledgment packet from the head unit in which the head unit will assign a numerical value to the sensor between 0 and 9998. The user is then able to assign a more descriptive identifying string to the sensor so that its location can be more apparent. Upon being triggered, the sensor will begin boardcasting a packed in the form of ‚ÄúSENSOR_ID:PACKET_ID:TRIG_VAL‚Äù where</p>
<ul>
  <li>PACKET_ID is a unique integer identifying the packet to ensure the head unit doesn‚Äôt register the same alert twice</li>
  <li>TRIG_VAL is an integer representative of the sensor‚Äôs states</li>
</ul>

<p>This packet is repeated every 0.5 seconds up until the sensor receives a packet from the head unit in the form of ‚Äú9999;SENSOR_ID;PACKET_ID‚Äù where</p>
<ul>
  <li>9999 is the equivalent SENSOR_ID for the head unit</li>
  <li>SENSOR_ID is the id of whichever sensor tripped</li>
  <li>PACKET_ID is the packet id</li>
</ul>
:ET